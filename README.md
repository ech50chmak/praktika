# PraktikaVsOSH Robotics Firmware

Небольшой проект на Arduino/PlatformIO для управления мобильной платформой с двумя ведущими колесами, энкодерами, линейными датчиками и сервоприводами. Прошивка реализует движение по линии, дуговые манёвры и реагирование на обнаружение объекта.

## Структура исходников

- `src/main.cpp` — основной скетч, содержащий всё управление роботом.
- `include/`, `lib/`, `test/` — директории PlatformIO под дополнительные заголовки, библиотеки и тесты (пока пустые).

## Аппаратные зависимости

- Плата Arduino с поддержкой Servo и PWM (например, Arduino Uno).
- Пины `8` и `9` используются как входы для энкодеров и одновременно читаются в прерываниях.
- Пины `10` и `13` — сервоприводы (манипулятор/дополнительный механизм).
- Аналоговые входы `A0–A3` (в коде — 14–17) задействованы для линейных датчиков и ИК-датчика расстояния.
- ШИМ-выходы `5`, `6` и цифровые пины `4`, `7` управляют драйвером двигателей.

## Разбор функций

### `void setup()`
- Настраивает прерывания на канал энкодеров, объявляет режимы пинов, привязывает сервоприводы и запускает `Serial`.
- **Особенности:** используется `attachInterrupt(0/1, ...)`, что жёстко привязано к цифровым пинам `2` и `3`. При переносе на другую плату лучше вызвать `attachInterrupt(digitalPinToInterrupt(pin), ...)` и явно настроить режим пинов.

### `void move(int speedL, int speedR)`
- Управляет направлением и скоростью левого/правого мотора через драйвер.
- Значения скоростей ограничиваются по модулю до `255`, знак определяет направление.
- **Риск:** функции чтения/записи глобальных `degL/degR` во время вызова не защищены от прерываний, что может приводить к артефактам при быстрых изменениях скорости.

### `void stop()`
- Сбрасывает энкодеры и пытается динамически удержать робот на месте: ~200 мс подаёт коррекцию, противоположную текущему отклонению по энкодерам.
- Завершает работу вызовом `move(0, 0)`.
- **Особенность:** часто вызывается перед поворотами и крупными манёврами, поэтому корректность `degL/degR` критична.

### `void ser(Servo &servo, int deg, int dly)`
- Плавно переводит сервопривод к целевому углу, дозируя задержку `dly` между шагами.
- Внутренний цикл инкрементирует или декрементирует текущий угол до целевого значения.

### `void callibration(int deg, int sign)`
- Запускает робота на дугу и собирает минимальные/максимальные значения с линейных датчиков.
- При вращении на `deg` тиков энкодера обновляет `s1min/max` и `s2min/max`.
- **Критично:** сейчас оба датчика читаются с пинов `14` и `15`, тогда как рабочая функция `LLS()` использует `analogRead(16)`. Из-за этого второй канал не калибруется, что приводит к делению на ноль в `map()`. Также минимумы инициализированы нулями — их нужно заменить на большие стартовые значения (например, `1023`).

### `int RLS()` и `int LLS()`
- Преобразуют значения правого/левого линейного датчика к диапазону `100–300`.
- Используют `map()` с калиброванными пределами `s1min/max` и `s2min/max`.
- **Риски:** отсутствие проверки на совпадающие границы (`min == max`) может вызвать деление на ноль. Следует добавить защиту и запасные значения.

### `void pd(int v)`
- ПД-регулятор движения по линии. Ошибка определяется разницей `RLS() - LLS()`.
- Коэффициенты `kp` и `kd` масштабируются относительно базовой скорости `v`.
- Управляющее воздействие распределяется как `move(v - u, v + u)`.

### `void pdARC(int s, int deg)`
- Вариант ПД-регулятора, который выравнивает скорость по энкодерам при движении по дуге.
- Текущая реализация игнорирует аргумент `deg`: ошибка берётся только как `degL - degR`.
- **Рекомендация:** либо использовать `deg` для смещения (например, заданная разница траектории), либо убрать параметр.

### `void arc(int s, int deg)`
- Сбрасывает счётчики энкодеров и запускает `pdARC` до достижения нужного угла (`deg` тиков).
- В конце вызывает `stop()`.
- **Замечание:** цикл не имеет запасного таймаута; при нерабочем энкодере выполнение застрянет.

### `void LFcross(int s, int cnt, int scan = 1)`
- Проезд через `cnt` перекрёстков линии с возможным сканированием объекта.
- Последовательно:
  1. Разгон до перекрёстка с плавным изменением скорости.
  2. Перепрохождение небольшой дистанции (`~210` тиков) для стабилизации.
  3. Опциональный подсчёт срабатывания датчика `IK()` — если было больше одного срабатывания, устанавливает флаг `ik` и вызывает `is_cube()`.
- **Тонкости:**
  - В выражении `min(1, cur_deg/aim_deg)` происходит целочисленное сравнение; нужно `min(1.0f, ...)`, чтобы плавный профиль скорости работал.
  - Многократные пустые `while` без задержек могут нагружать процессор. Подумайте об интервалах или таймаутах.

### `void LFenc(int s, int deg)`
- Линейное движение по энкодерам с использованием `pd` до набора заданного угла.
- Завершает выполнение вызовом `stop()`.

### `void turn(int side)`
- Поворот на месте: серия скоростей `140`, `80`, затем `60` для точного доведения.
- Использует линейные датчики для определения момента, когда робот повернулся на линию.
- **Риск:** каждый цикл ожидания (`while (...) {}`) без таймаута зависнет при проблемах с датчиками.

### `int IK()`
- Оценка расстояния по ИК-датчику: `32 * pow(analogRead(17)*5/1024.0, -1.1)`.
- Модель основана на обратной степенной функции.
- **Важно:** при `analogRead(17) == 0` выражение даёт бесконечность. Добавьте нижний порог (например, возвращать максимальное расстояние).

### `void is_cube()`
- Если флаг `ik` установлен, останавливает робота и делает паузу 500 мс.
- Предполагается, что дальнейшая логика (захват/манипуляция) будет добавлена позже.

### `void loop()`
- Пока пустой. Предполагается, что сценарий движения будет реализован пользователем (набор вызовов `callibration`, `LFcross`, `turn` и т.д.).

## Известные проблемы и рекомендации

- **Калибровка линейных датчиков:** исправить пины и стартовые значения `s1min/s2min/s1max/s2max`, добавить защиту от деления на ноль.
- **Потокобезопасность энкодеров:** операции с `degL/degR` (чтение/запись/сброс) лучше оборачивать в `noInterrupts()`/`interrupts()` на 8-битных платах.
- **Таймауты:** все длинные `while`-циклы стоит дополнить контролем времени.
- **`IK()` защита:** обработать нулевой вход и ограничения на возвращаемое значение.

## Сборка и прошивка

```bash
pio run           # сборка
pio run -t upload # прошивка, если плата подключена
pio device monitor
```

Перед стартом обязательно вызовите калибровку датчиков (`callibration`) и убедитесь в корректности подключений.
